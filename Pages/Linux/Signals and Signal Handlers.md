#linux

In Linux, **signals** are a form of inter-process communication (IPC) used to notify processes of events or conditions that require attention. Signals can be generated by the kernel, other processes, or even the process itself. Each signal is associated with a number (signal number) and a name (e.g., `SIGKILL`, `SIGTERM`, `SIGSEGV`). Signals may interrupt a processâ€™s execution, terminate it, or modify its behavior, depending on how the signal is handled.

### 1. **Overview of Signals**

### **1.1 What is a Signal?**

A signal is a limited form of communication used to notify a process that some event has occurred. When a signal is sent to a process, the process is interrupted, and depending on the signal, it may handle the signal in a certain way.

- **Signals can be sent by:**
    - **The kernel**: For example, a segmentation fault (`SIGSEGV`) or when a process exceeds its time limit.
    - **Other processes**: For instance, sending a signal to terminate a process (`SIGTERM`).
    - **The process itself**: A process may send signals to itself or other processes, such as for internal handling of errors or conditions.

### **1.2 Types of Signals**

- **Standard signals**: These signals are predefined and part of the POSIX specification.
    - **Examples**:
        - `SIGTERM` (15): Request termination.
        - `SIGKILL` (9): Immediate termination (cannot be caught or ignored).
        - `SIGINT` (2): Interrupt signal (Ctrl+C).
        - `SIGSEGV` (11): Segmentation fault (e.g., accessing memory the process doesn't have permission to access).
        - `SIGSTOP` (19): Stop a process (cannot be caught or ignored).
- **Real-time signals**: These are used for specific purposes, such as event-driven systems. They have numbers starting from 32.
    - **Examples**:
        - `SIGRTMIN`, `SIGRTMAX`, etc.

### **1.3 Signal Categories**

- **Default Actions**: Signals can have default actions that the operating system takes when the signal is delivered. For instance:
    - **Terminate**: For `SIGTERM`, `SIGSEGV`, etc.
    - **Ignore**: For some signals like `SIGCHLD`.
    - **Stop**: For `SIGSTOP`, `SIGTSTP`.
- **Handled**: The process has defined a custom handler for a signal.
- **Ignored**: The process ignores the signal entirely.

---

### 2. **Signal Handlers**

A **signal handler** is a function defined in a process to handle specific signals. When a signal is received, if the process has a handler for it, the handler function is called. Signal handlers allow a process to define custom behavior upon receiving a signal.

### **2.1 How Signal Handlers Work**

When a signal is sent to a process, the signal handler is invoked to deal with the signal, either by performing some action or by ignoring the signal. If the process does not have a handler for the signal, the **default action** (e.g., termination, stopping) occurs.

### **2.2 Installing a Signal Handler**

To install a signal handler in Linux, you can use the `signal()` system call or `sigaction()`, which provides more flexibility.

**Using `signal()`**:

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void signal_handler(int signum) {
    printf("Received signal %d\\n", signum);
    // Custom behavior for the signal
}

int main() {
    signal(SIGINT, signal_handler);  // Handle Ctrl+C (SIGINT)
    while (1) {
        printf("Running...\\n");
        sleep(1);
    }
    return 0;
}

```

- In the above example, when the program receives a `SIGINT` (Ctrl+C), the `signal_handler` function is executed.

**Using `sigaction()`** (preferred for more control):

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>

void signal_handler(int signum) {
    printf("Received signal %d\\n", signum);
    // Custom behavior for the signal
}

int main() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = signal_handler;
    sigaction(SIGINT, &sa, NULL);  // Handle Ctrl+C (SIGINT)

    while (1) {
        printf("Running...\\n");
        sleep(1);
    }
    return 0;
}

```

- `sigaction()` provides more control, allowing for flags like `SA_RESTART` (restarting interrupted system calls) or `SA_SIGINFO` (providing additional signal information).

---

### 3. **Signal Handling Mechanics**

### **3.1 Signal Masking**

Signal masking involves blocking or temporarily ignoring signals. This is typically done to ensure that a critical section of code is not interrupted by signals.

- **Blocking signals**: This can be achieved using `sigprocmask()` or `pthread_sigmask()` for thread-level control.
    
    ```c
    sigset_t new_mask, old_mask;
    sigemptyset(&new_mask);
    sigaddset(&new_mask, SIGINT);
    sigprocmask(SIG_BLOCK, &new_mask, &old_mask);
    
    ```
    

### **3.2 Asynchronous Nature of Signals**

Signals are asynchronous in nature, meaning they can interrupt the execution of the process at any point. This is important to keep in mind when dealing with signal handlers since modifying shared data without proper synchronization may lead to **race conditions**.

### **3.3 Signal Queuing and Delivery**

- **Multiple signals**: If a signal is sent multiple times to a process, only the first signal is delivered. However, **real-time signals** can be queued and delivered in order.
- **Signal Delivery**: When a signal is delivered to a process, it suspends its current execution and invokes the signal handler (if defined). After the handler completes, the process resumes from the point it was interrupted.

---

### 4. **Signal Handling Considerations**

### **4.1 Safe Signal Handling**

Signal handlers should only call **async-signal-safe** functions, which are functions guaranteed to be safe for use within a signal handler (e.g., `write()`, `exit()`, `signal()`). Unsafe functions include `malloc()`, `printf()`, etc., as they may not be reentrant and could cause undefined behavior.

### **4.2 Reentrant Functions**

Reentrant functions are those that can be interrupted and safely resumed without causing inconsistencies. In the context of signal handling, you must use reentrant functions to avoid issues when a signal occurs while the process is executing a system call.

### **4.3 Signals and Child Processes**

When a process spawns a child, the child may inherit certain signal dispositions. Additionally, signals like `SIGCHLD` (child stopped or exited) are sent to the parent when the child process terminates.

### **4.4 Signal Terminology**

- **Signal handler**: A function defined to handle a specific signal.
- **Signal disposition**: The action taken by the process upon receiving a signal (default, custom handler, or ignore).
- **Signal blocking**: Temporarily stopping the delivery of signals to a process.

---

### 5. **Common Signals and Their Default Actions**

- **`SIGINT` (2)**: Interrupt from keyboard (Ctrl+C). Default: Terminate.
- **`SIGTERM` (15)**: Request termination. Default: Terminate.
- **`SIGKILL` (9)**: Force termination. Default: Terminate (cannot be caught).
- **`SIGSEGV` (11)**: Segmentation fault (invalid memory access). Default: Core dump, terminate.
- **`SIGSTOP` (19)**: Stop the process. Default: Stop (cannot be caught).
- **`SIGCHLD` (17)**: Child process stopped or terminated. Default: Ignore.
- **`SIGUSR1`, `SIGUSR2`**: User-defined signals. Default: Terminate.

---

### 6. **Conclusion**

Linux signals and signal handlers provide a mechanism for processes to react to events asynchronously. They allow for communication between processes and enable a wide range of behaviors, from handling errors to managing process control. Signal handling needs to be done carefully, especially with respect to asynchronous nature and safe programming practices to avoid race conditions and other pitfalls.