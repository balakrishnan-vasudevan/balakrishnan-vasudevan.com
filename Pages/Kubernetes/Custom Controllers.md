While there are many Controllers built into Kubernetes clusters by default, users may want to extend the functionality of their clusters by enabling additional custom Controllers called Operators. Operators are custom Controllers that implement the [Operator Pattern](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/), an approach to adding new automation into Kubernetes.

Operators are typically deployed as regular Kubernetes workloads, such as Deployments or StatefulSets.

The Operator is configured to monitor for custom Kubernetes resource types, which are defined via the Kubernetes object called [Custom Resource Definitions](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/) (CRDs). CRDs are a vital aspect of understanding the use case and benefit of Operators. These objects are practically always combined to extend a Kubernetes cluster's functionality.

A CRD allows users to define new Kubernetes objects beyond the defaults like Pods, Deployments, Nodes, etc. The CRD's schema will tell Kubernetes about the schema for the new object, such as what values it will contain inside the .spec section. For example, we could define a new CRD for a resource called "Database,". Once it is deployed, Kubernetes will become aware that a new "Database" object type is available. The user can now deploy objects with a "kind: Database" and interact via standard API calls like _kubectl get database_.

Defining a new Kubernetes object will only impact a cluster if there is an associated Controller to observe and perform some reconciliation within the cluster. Users can deploy an Operator to observe their new object and perform custom cluster actions to extend the cluster's default functionality.

There are many packaged Operators available for Kubernetes that users can deploy directly. It's also possible for users to develop their own Operators using frameworks like the [Operator SDK](https://sdk.operatorframework.io/) and [Kube Builder](https://github.com/kubernetes-sigs/kubebuilder). Tools like these aim to simplify the developer experience by providing libraries for connecting to the Kubernetes API and performing common actions, like watching resources. Users may develop their own Operators to fulfill use cases that go beyond the default capabilities of Kubernetes. Leveraging Operators is a powerful way to extend cluster functionality and is a key aspect of why Kubernetes is so compelling; expanding a cluster's functionality by plugging in new Operators allows for a high degree of customization and personalization.

