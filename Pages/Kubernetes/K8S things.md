
https://ymmt2005.hatenablog.com/entry/k8s-things

| **Criteria**| **Option** |   
| -------- | -------- | 
| Extension mechanisms for kube-apiserver| [Custom resources](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/): to define custom resources using OpenAPI schema  <br> [Aggregation layer](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/): to configure reverse-proxy servers to provide additional API groups <br> [Admission webhooks](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks): to validate or mutate resources before saving them to etcd <br>  [Authentication webhook](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication): to verify authentication tokens with external authentication servers <br> [Authorization webhook](https://kubernetes.io/docs/reference/access-authn-authz/webhook/): to authorize requests with external authorization servers
| operation sequence of admission controls| 1. Authentication and authorization <br> 2. Mutating webhook <br> 3. Object schema validation <br> 4. Validating webhook <br> 5. Saving data to etcd <br> cf. [A Guide to Kubernetes Admission Controllers](https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/)
| problem and solution when multiple mutating webhooks edit the same resource| There is no way to specify the order of applying mutating webhooks for kube-apiserver. <br> Suppose we have two mutating webhooks to edit Pods, one is to add a volume mount configuration to all containers, and another is to add a container. To make all containers have the volume mount configuration, the first webhook needs to be called **after** the second. <br> We can set [the reinvocation policy](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#reinvocation-policy) of the first webhook to `IfNeeded` to make the first called after the second.
| what happens when a call of an admission webhook fails | It depends on the setting of [failure policy](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#failure-policy) of the webhook. For `admissionregistration.k8s.io/v1`, the default is `Fail` so that the request is rejected.
| how kube-apiserver prevents resource editing conflicts| All resources saved in etcd have a resource version that is updated every time it is edited. kube-apiserver utilizes this to reject conflicting edit requests if the resource revision is different from the saved one. <br> This mechanism is called _optimistic locking_ and is applied to all PUT (update) requests. <br> cf. [Optimistic lock control for Kubernetes API Server object modification](https://www.programmersought.com/article/87603469758/)  
| operation sequence of admission controls| 1. Authentication and authorization <br> 2. Mutating webhook <br> 3. Object schema validation <br> 4. Validating webhook <br> 5. Saving data to etcd <br> cf. [A Guide to Kubernetes Admission Controllers](https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/)
|List and describe available PATCH methods|JSON Patch: can be used for both built-in and custom resources. <br> JSON Merge Patch: ditto. For the difference from JSON patch, read http://erosb.github.io/post/json-patch-vs-merge-patch/ . <br> Strategic Merge Patch: can be used for only built-in resources. <br> Server Side Apply: can be used for both built-in and custom resources. <br> This works substantially differently from others. Fields in resources may have owners, and the owners manage only their fields. <br> cf. PATCH operations <br> cf. An example of using dynamic client of k8s.io/client-go <br> |subresources|Subresources are a partial element of a resource for which a REST API endpoint is provided separately from the main resource. The most common subresource is /status that represents status element. <br> Since subresources have an independent set of API endpoint and verbs, they have independent RBAC permissions from the main resources. <br> cf. Types (Kinds)
|Describe what is the storage version of API|Each Kubernetes API is versioned. When an incompatible change is introduced to an API, its version is bumped. <br> When an API resource is saved in etcd, the resource is converted to a specific version of the API and serialized. This specific version is called the storage version of the API.
|how to bump Kubernetes API version step by step|Introduce a new API version. The storage version of the API stays the old version. <br> Change the storage version to the new one after the new version gets stabilized and matured. <br> Update the saved API resources in etcd to the new version (by updating them). <br> Deprecate the old API version. Tell users to update their resources to the new version. <br> Remove the old API version after a while. <br> cf. The Future of Your CRDs – Evolving an API
|why conversion webhooks have to implement a round-trip conversion|Suppose that an API sets v1 as its storage version. <br> When creating the API resource as v2, the conversion webhook needs to convert the resource from v2 to v1. kube-apiserver then saves the resource as v1 in etcd. <br> When retrieving the API resource as v2, the conversion webhook needs to convert back the saved resource from v1 to v2. <br> Clearly, the conversion webhook needs to implement a round-trip conversion. <br>
|how to avoid missing information in round-trip conversion|The common technique is to save the missing information as annotations. For instance, HorizontalPodAutoscaler saves fields added in v2 as annotations in v1. <br> cf. Horizontal Pod Autoscaler
|how kube-apiserver and aggregation API servers authenticate/authorize each other|They mutually authenticate each other using TLS. Read Authentication Flow for details. <br> As to authorization, aggregation API servers have to be granted to create SubjectAccessReview resources by kube-apiserver. <br> To grant the privilege, bind a system built-in Role called extension-apiserver-authentication-reader in kube-system namespace to the ServiceAccount of the aggregation API server.
