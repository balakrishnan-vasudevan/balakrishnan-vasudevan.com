Source: https://levelup.gitconnected.com/how-to-generate-unique-ids-in-distributed-systems-6-key-strategies-37a8ab3b367d

Various strategies cater to these requirements, with each being apt to these requirements:

- Uniqueness: Every ID generated should be unique across all nodes in the system.
- Scalable: The system should be able to generate IDs at a high rate without collisions.
- Monotonically Increasing: (If needed) The IDs should increase over time.

![[Pasted image 20250324151704.png]]

| Method                      | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Pros                                                                                                                                                                                                                                                                                                                                                                                                                         | Cons                                                                                                                                                                                                                                        |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| UUID                        | A UUID is made of 32 hexadecimal characters. Remember, each character is 4 bits. So, all in all, it’s 128 bits. And when you include the 4 hyphens, you’ll see 36 characters.<br>- **Version 1 — Time-based MAC**: This UUID uses the MAC Address of your computer and the current time.<br>- **Version 2 — DCE Security**: Similar to Version 1 but with extra info like POSIX UID or GID.<br>- **Version 3 — Name-based MD5**: This one takes a namespace and a string, then uses MD5 to create the UUID.<br>- **Version 4 — Randomness**: Every character is chosen randomly.<br>- **Version 5 — Name-based SHA1**: Think of Version 3, but instead of MD5, it uses SHA-1.<br>- **Version 6 — Reordered Time**: A tweak to Version 1, allowing UUIDs to be sorted by creation time, optimizing database storage.      | - It’s simple, there’s no need for initial setups or a centralized system to manage the ID.<br>- Every service in your distributed system can roll out its own unique ID, no chit-chat needed.                                                                                                                                                                                                                               | - With 128 bits, it’s a long ID and it’s not something you’d easily write down or remember.<br>- It doesn’t reveal much information about itself.<br>- UUIDs aren’t sortable (except for versions 1 and 2).                                 |
| NanoID                      | NanoID streamlines things a bit with just 21 characters but these characters are sourced from an alphabet of 64 characters, inclusive of hyphens and underscores.<br><br>Doing the math, each NanoID character takes up 6 bits, as opposed to the 4 bits of UUID and a quick multiplication, and we see NanoID coming in at a neat 126 bits.                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | - NanoID uses characters (A-Za-z0–9_-) which is friendly with URLs.<br>- At just 21 characters, it’s more compact than UUID, shaving off 15 characters to be precise (though it’s 126 bits versus UUID’s 128)                                                                                                                                                                                                                | - NanoID is newer and might not be as widely supported as UUID.                                                                                                                                                                             |
| Sequences                   | At its core, there’s a centralized counter ticking upwards, but picture a scenario with millions of simultaneous requests. This central point then turns into both a bottleneck and a potential single point of failure.<br>> **So, what? We can’t distribute the load or something?”**<br><br>Absolutely. Instead of one centralized generator, each node can have its very own ID generator, incrementing as it goes.<br>While the system is distributed, each node can still be a bottleneck, if a node is overwhelmed with countless requests, it will process them one after the other.                                                                                                                                                                                                                             | - It’s a straightforward approach with the added bonus of sortable IDs, making it apt for small to medium-sized systems.                                                                                                                                                                                                                                                                                                     | - Doesn’t perform well under sudden, high-volume request spikes.<br>- Removing nodes in a decentralized system can complicate matters<br>- IDs from a decentralized model don’t follow a global sequence, complicating any sorting efforts. |
| ObjectID (96 bits)          | ObjectID is MongoDB’s answer to a unique document ID, this 12-byte identifier typically resides in the “_id” field of a document, and if you’re not setting it yourself, MongoDB steps in to do it for you.<br><br>Here’s what makes up an `ObjectID`:<br><br>- **Timestamp (4 bytes)**: This represents the time the object was created, measured from the Unix epoch (a timestamp from 1970, for those who might need a refresher).<br>- **Random Value (5 bytes)**: Each machine or process gets its own random value.<br>- **Counter (3 bytes)**: A simple incrementing counter for a given machine.<br>                                                                                                                                                                                                             | - Ensures a global order without needing a centralized authority to oversee uniqueness<br>- In terms of byte size, it’s more compact than both UUID and NanoID.<br>- Using IDs for sorting is straightforward, and you can easily see when each object was made.<br>- Reveals the specific process or machine that created an item.<br>- Scales gracefully, thanks to its time-based structure ensuring no future conflicts. | - Despite its relative compactness, 96 bits can still be considered long.<br>- Be careful when sharing ObjectIDs with clients, they might reveal too much.                                                                                  |
| Twitter Snowflake (64 bits) | Commonly known as “Snowflake ID”, this system was developed by Twitter to efficiently generate IDs for their massive user base.<br><br>Also, a Snowflake ID boils down to a 64-bit integer, which is more compact than MongoDB’s ObjectID<br><br>- Sign Bit (1 bit): This bit is typically unused, though it can be reserved for specific functions.<br>- Timestamp (41 bits): Much like ObjectID, it represents data creation time in milliseconds, spanning ~70 years from its starting point.<br>- Datacenter ID (5 bits): Identifies the physical datacenter location. With 5 bits, we can have up to 2⁵ = 32 datacenter.<br>- Machine/ Process ID (5 bits): Tied to individual machines, services, or processes creating data.<br>- Sequence (12 bits): An incrementing counter that resets to 0 every millisecond. |                                                                                                                                                                                                                                                                                                                                                                                                                              | - Might be over-engineered for medium-sized businesses, especially with complex setups like multiple data centers, millisecond-level timestamps, sequence resets...                                                                         |
| Snowflake                   | Get inspired by Snowflake, Sonyflake makes a few alterations in the distribution of its bits:<br><br>- **Sign bit (1 bit)**<br>- **Timestamp (39 bits)**: Sonyflake operates at 10 milliseconds, expands the duration coverage from ~70 years (like in Snowflake) to ~174 years<br>- **Machine/ Process ID (16 bits)**<br>- **Sequence (8 bits)**: This permits 256 IDs every 10 ms, this is somewhat slower than Snowflake, it increases the chance of ID overlap during peak time.                                                                                                                                                                                                                                                                                                                                     | Given its specifications, Sonyflake seems suitable more for small to medium-sized systems where extreme speed and scale aren’t important.                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                             |
