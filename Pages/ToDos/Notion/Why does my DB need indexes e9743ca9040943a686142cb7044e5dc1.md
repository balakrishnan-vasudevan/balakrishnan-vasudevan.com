# Why does my DB need indexes?

Tags: databases
Category: Articles
Company: general
Status: Not started

# https://orangematter.solarwinds.com/2021/05/27/why-does-my-database-need-indexes/

An index is a linked copy of a subset of a table existing within the same database. It can consist of one or more columns (and it doesn’t have to include all of the rows). The index is linked to the table so when data is inserted, updated, or deleted in the table, it’s reflected in the index before the transaction is marked complete by the database. Indexes allow the query optimizer to use a subset of the table data.

Here’s an example: *SELECT FirstName, LastName* *FROM Employees* *WHERE LastName = ‘Smith’*  **This query retrieves the first name and last name from the table named Employees. If you don’t have an index, the query would have to read the entire table. But if you have an index of the LastName column, instead of reading the entire table, the engine will only read the specific column. While this might seem minor at first, if I told you the Employees table has 50 columns and 10,000,000 rows, the reduction in records read suddenly becomes significant. And this is especially the case when you’re retrieving a small number of records, such as the balance of a specific customer.

indexes need their own space on disk, and are kept in sync with the data in the table. If we go back to our 50-column Employees table, 50 indexes would mean every time a new record was written, to complete the write to the main table, the database engine would need to write to every one of those 50 indexes. As you can imagine, this would drastically decrease the performance of write operations. And those 50 indexes would take up a lot of disk space. Which columns should you index? The obvious answer is any columns referenced in the *where* and *order by* clauses of commonly executed queries. 

The two most common are clustered and nonclustered indexes. A clustered index is the actual table data, sorted by the clustering key (usually the primary key of the table). Tables without clustered indexes are called heaps—this pattern is common in Oracle, but less common in other databases. An exception to this is temporary staging tables, which are designed strictly with data ingest speed in mind. A nonclustered index, on the other hand, is an on-disk structure separate from the data rows in the table, like our LastName example. In the LastName example, LastName would be considered the key in our nonclustered index which has a pointer in the nonclustered index points at a row locator in a clustered index, or heap, allowing for rapid retrieval of the row. You also have the option to include additional columns in a nonclustered index—these columns aren’t part of the key, and are used for additional columns potentially required for the query. These included columns can significantly improve performance by eliminating lookups to the base table to retrieve records. Other common index types include those for nested datatypes like XML and JSON, which allow data to be queried more efficiently. Another modern type of index is columnstore, which stores data in columns. This allows for a great deal of data compression, and is helpful for large aggregation queries like those encountered in a data warehouse. These latter types of indexes are more for special use, and you should investigate the options available in your database platform.